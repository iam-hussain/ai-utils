import { RunnableLambda, _coerceToRunnable, } from "@langchain/core/runnables";
import { Channel, Pregel } from "../pregel/index.js";
export const END = "__end__";
class Branch {
    constructor(condition, ends) {
        Object.defineProperty(this, "condition", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "ends", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.condition = condition;
        this.ends = ends;
    }
    async runnable(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    input, options) {
        const result = await this.condition(input, options?.config);
        let destination;
        if (this.ends) {
            destination = this.ends[result];
        }
        else {
            destination = result;
        }
        return Channel.writeTo(destination !== END ? `${destination}:inbox` : END);
    }
}
export class Graph {
    constructor() {
        Object.defineProperty(this, "nodes", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "edges", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "branches", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "entryPoint", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "compiled", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        this.nodes = {};
        this.edges = new Set();
        this.branches = {};
    }
    warnIfCompiled(message) {
        if (this.compiled) {
            console.warn(message);
        }
    }
    addNode(key, action) {
        this.warnIfCompiled(`Adding a node to a graph that has already been compiled. This will not be reflected in the compiled graph.`);
        if (this.nodes[key]) {
            throw new Error(`Node \`${key}\` already present.`);
        }
        if (key === END) {
            throw new Error(`Node \`${key}\` is reserved.`);
        }
        this.nodes[key] = _coerceToRunnable(action);
    }
    addEdge(startKey, endKey) {
        this.warnIfCompiled(`Adding an edge to a graph that has already been compiled. This will not be reflected in the compiled graph.`);
        if (startKey === END) {
            throw new Error("END cannot be a start node");
        }
        if (!this.nodes[startKey]) {
            throw new Error(`Need to addNode \`${startKey}\` first`);
        }
        if (!this.nodes[endKey] && endKey !== END) {
            throw new Error(`Need to addNode \`${endKey}\` first`);
        }
        // TODO: support multiple message passing
        if (Array.from(this.edges).some(([start]) => start === startKey)) {
            throw new Error(`Already found path for ${startKey}`);
        }
        this.edges.add([startKey, endKey]);
    }
    addConditionalEdges(startKey, condition, conditionalEdgeMapping) {
        this.warnIfCompiled("Adding an edge to a graph that has already been compiled. This will not be reflected in the compiled graph.");
        if (!this.nodes[startKey]) {
            throw new Error(`Need to addNode \`${startKey}\` first`);
        }
        if (conditionalEdgeMapping) {
            const mappingValues = Array.from(Object.values(conditionalEdgeMapping));
            const nodesValues = Object.keys(this.nodes);
            const endExcluded = mappingValues.filter((value) => value !== END);
            const difference = endExcluded.filter((value) => !nodesValues.some((nv) => nv === value));
            if (difference.length > 0) {
                throw new Error(`Missing nodes which are in conditional edge mapping.\nMapping contains possible destinations: ${mappingValues.join(", ")}.\nPossible nodes are ${nodesValues.join(", ")}.`);
            }
        }
        if (!this.branches[startKey]) {
            this.branches[startKey] = [];
        }
        this.branches[startKey].push(new Branch(condition, conditionalEdgeMapping));
    }
    setEntryPoint(key) {
        this.warnIfCompiled("Setting the entry point of a graph that has already been compiled. This will not be reflected in the compiled graph.");
        if (!this.nodes[key]) {
            throw new Error(`Need to addNode \`${key}\` first`);
        }
        this.entryPoint = key;
    }
    setFinishPoint(key) {
        this.warnIfCompiled("Setting a finish point of a graph that has already been compiled. This will not be reflected in the compiled graph.");
        this.addEdge(key, END);
    }
    compile(checkpointer) {
        this.validate();
        const outgoingEdges = {};
        this.edges.forEach(([start, end]) => {
            if (!outgoingEdges[start]) {
                outgoingEdges[start] = [];
            }
            outgoingEdges[start].push(end !== END ? `${end}:inbox` : END);
        });
        const nodes = {};
        for (const [key, node] of Object.entries(this.nodes)) {
            nodes[key] = Channel.subscribeTo(`${key}:inbox`)
                .pipe(node)
                .pipe(Channel.writeTo(key));
        }
        for (const key of Object.keys(this.nodes)) {
            const outgoing = outgoingEdges[key];
            const edgesKey = `${key}:edges`;
            if (outgoing || this.branches[key]) {
                nodes[edgesKey] = Channel.subscribeTo(key, {
                    tags: ["langsmith:hidden"],
                });
            }
            if (outgoing) {
                nodes[edgesKey] = nodes[edgesKey].pipe(Channel.writeTo(...outgoing));
            }
            if (this.branches[key]) {
                this.branches[key].forEach((branch) => {
                    const runnableLambda = new RunnableLambda({
                        func: (input) => branch.runnable(input),
                    });
                    nodes[edgesKey] = nodes[edgesKey].pipe(runnableLambda);
                });
            }
        }
        const hidden = Object.keys(this.nodes).map((node) => `${node}:inbox`);
        if (!this.entryPoint) {
            throw new Error("Entry point not set");
        }
        return new Pregel({
            nodes,
            input: `${this.entryPoint}:inbox`,
            output: END,
            hidden,
            checkpointer,
        });
    }
    validate() {
        const allStarts = new Set([...this.edges].map(([src, _]) => src).concat(Object.keys(this.branches)));
        for (const node of Object.keys(this.nodes)) {
            if (!allStarts.has(node)) {
                throw new Error(`Node \`${node}\` is a dead-end`);
            }
        }
        const allEndsAreDefined = Object.values(this.branches).every((branchList) => branchList.every((branch) => branch.ends));
        if (allEndsAreDefined) {
            const allEnds = new Set([...this.edges]
                .map(([_, end]) => end)
                .concat(...Object.values(this.branches).flatMap((branchList) => branchList.flatMap((branch) => Object.values(branch.ends ?? {}))))
                .concat(this.entryPoint ? [this.entryPoint] : []));
            for (const node of Object.keys(this.nodes)) {
                if (!allEnds.has(node)) {
                    throw new Error(`Node \`${node}\` is not reachable`);
                }
            }
        }
        this.compiled = true;
    }
}
